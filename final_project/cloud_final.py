#!/usr/bin/env python

# [START imports]
from google.appengine.ext import ndb
import webapp2
import jinja2
import json
import logging
import os
import hashlib
import urllib
import time
from google.appengine.api import urlfetch
# [END imports]

# [START State declaration]
class State(ndb.Model): 
    id = ndb.StringProperty(),
    state = ndb.StringProperty()
# [END State declaration]

JINJA_ENVIRONMENT = jinja2.Environment(
    loader=jinja2.FileSystemLoader(os.path.dirname(__file__)),
    extensions=['jinja2.ext.autoescape'],
    autoescape=True)

# [START Car declaration]
class Car(ndb.Model): #set up the structure of car data
    id = ndb.StringProperty()
    year = ndb.StringProperty()
    make = ndb.StringProperty()
    model = ndb.StringProperty()
    in_space = ndb.BooleanProperty()
    owner_id = ndb.StringProperty()
# [END Car declaration]

# [START Space declaration]
class Space(ndb.Model): #set up the structure of space data
	id = ndb.StringProperty()
	number = ndb.IntegerProperty()
	current_car = ndb.StringProperty()
	arrival_date = ndb.StringProperty()
# [END Space declaration]

def sendErrorResponse(x, status, message):
	x.response.headers.add('Content-Type', 'Application/JSON')
	x.response.set_status(status)
	r = {}
	r['message'] = message
	x.response.write(json.dumps(r))

def sendSuccessResponse(x, status, d):
	x.response.headers.add('Content-Type', 'Application/JSON')
	x.response.set_status(status)
	x.response.write(json.dumps(d))

def getUserEmail(token):
	auth_header = 'Bearer ' + token
	headers = {
		'Authorization' : auth_header
	}

	result = urlfetch.fetch(url="https://www.googleapis.com/plus/v1/people/me", headers=headers, method=urlfetch.GET)
	time.sleep(0.2) #wait a little bit for the request to finish
	results = json.loads(result.content)
	plusUser = results['isPlusUser']

	if (plusUser == True):
		email_address = results['emails'][0]['value']
	else:
		email_address = 'anonymous'

	return email_address

def checkAuth(x):
	headers = x.request.headers #grab the header of the request
	if ('Authorization' in headers.keys()):
		token = headers['Authorization']
	else:
		return -1

	auth_header = 'Bearer ' + token
	headers = {
		'Authorization' : auth_header
	}

	result = urlfetch.fetch(url="https://www.googleapis.com/plus/v1/people/me", headers=headers, method=urlfetch.GET)
	time.sleep(0.2)
	results = json.loads(result.content)
	if ('error' in results):
		return 0
	else:
		return 1

# [START CarHandler]
class CarHandler(webapp2.RequestHandler):
    # [START post handler]
    def post(self): #post request handler
    	#first check if Authorization token is procided
    	isAuthorized = checkAuth(self)
    	if (isAuthorized == -1):
    		sendErrorResponse(self, 400, "No authorization token provided")
    		return
    	elif (isAuthorized == 0):
    		sendErrorResponse(self, 400, "Invalid token provided")
    		return
    	else:
	    	#next validate inputs
	    	car_data = json.loads(self.request.body) #grab the body of the request

	        if ('year' in car_data.keys()):
	            yearVar = car_data['year']
	        else:
	            yearVar = ""

	        if ('make' in car_data.keys()):
	            makeVar = car_data['make']
	        else:
	            makeVar = ""

	        if ('model' in car_data.keys()):
	            modelVar = car_data['model']
	        else:
	            modelVar = ""

	        if (yearVar == "" or makeVar == "" or modelVar == ""): #set up a response if incomplete data is sent
	            sendErrorResponse(self, 400, "Year, Make, and Model are all required")
	            return
	        else: #if complete data is supplied, grab user data from Google plus, then create the Car
				email = getUserEmail(self.request.headers['Authorization'])
				new_car = Car(id="", year=yearVar, make=makeVar, model=modelVar, in_space=False, owner_id=email) #assign values 
				new_car.put() #save the fields we have
				new_car.id = str(new_car.key.id()) #get the id generated by datastore
				new_car.put() #save the id to the car we created
				car_dict = new_car.to_dict() #convert to a dictionary
				car_dict['self'] = '/cars/' + new_car.key.urlsafe() #add self element to dictionary
				sendSuccessResponse(self, 200, car_dict)
				return

    # [END post handler]

    # [START get handler]
    def get(self, id=None): #get request handler
		isAuthorized = checkAuth(self)

		if (isAuthorized == -1): #no token given, display all cars without owner id
			if id: #if looking for a specific car
				c = ndb.Key(urlsafe=id).get()
				c_d = c.to_dict()
				c_d['self'] = "/cars/" + c.key.urlsafe()
				del c_d['owner_id'] #keep the results anonymous
				sendSuccessResponse(self, 200, c_d)
			else:
				results = [] #create array to store query results
				qry = Car.query()
				qryResults = qry.fetch()
				for x in qryResults:
					x_d = x.to_dict()
					del x_d['owner_id'] #keep the results anonymous
					x_d['self'] = "/cars/" + x.key.urlsafe()
					results.append(x_d)
				sendSuccessResponse(self, 200, results)
				return    		
		elif (isAuthorized == 0): #if invalid token provided
			sendErrorResponse(self, 400, "Invalid token provided")
			return
		else:
			email = getUserEmail(self.request.headers['Authorization']) #get the owner id
			if id: #if looking for a specific car
				c = ndb.Key(urlsafe=id).get() #get the car object referred to by that id
				c_d = c.to_dict()
				if (email == c_d['owner_id']):
					c_d['self'] = "/cars/" + id
					sendSuccessResponse(self, 200, c_d)
				else:
					sendErrorResponse(self, 400, "You aren't authorized to view the details of this car")
			else: #if looking for all cars that owner possesses
				results = []
				qry = Car.query()
				qryResults = qry.fetch()
				for x in qryResults:
					x_d = x.to_dict()
					if (x_d['owner_id'] == email):
						x_d['self'] = '/cars/' + x.key.urlsafe()
						results.append(x_d)
				sendSuccessResponse(self, 200, results)
				return
    # [END get handler]

	# [START patch handler]
    def patch(self, id):
		isAuthorized = checkAuth(self) #check if the user is authorized to alter car data

		if (isAuthorized == -1): #if no token give, display an error
			sendErrorResponse(self, 400, "No authorization token provided")
			return
		elif (isAuthorized == 0): #if an invalid token is provided, send an error
			sendErrorResponse(self, 400, "Invalid token provided")
			return
		else:
			email = getUserEmail(self.request.headers['Authorization']) #get the owner id to confirm user is authorized to change provided car id
			c = ndb.Key(urlsafe=id).get() #get the car by id
			if (email != c.owner_id): #if the email from the token provided doesn't match the owner id on the car, send an error
				sendErrorResponse(self, 400, "You aren't authorized to alter the details of this car")
				return
			else:
				car_data = json.loads(self.request.body) #get the request parameters
				continueVar = 0

				#check which fields were sent to be updated
				if ('year' in car_data.keys()):
					c.year = car_data['year']
					continueVar = 1

				if ('make' in car_data.keys()):
					c.make = car_data['make']
					continueVar = 1

				if ('model' in car_data.keys()):
					c.model = car_data['model']
					continueVar = 1

				if (continueVar == 1): #if something was submitted to be changed, continue, else send error
					c.put() #commit the changes to the car

					c_d = c.to_dict()
					c_d['self'] = '/cars/' + id
					sendSuccessResponse(self, 200, c_d)
					return
				else:
					sendErrorResponse(self, 400, "No fields submitted to update")
					return

    # [END patch handler]

    # [START put handler]
    def put (self, id):
        isAuthorized = checkAuth(self) #check if the user is authorized to alter car data

        if (isAuthorized == -1): #if no token given, display an error
            sendErrorResponse(self, 400, "No authorization token provided")
            return
        elif (isAuthorized == 0): #if an invalid token is provided, send an error
            sendErrorResponse(self, 400, "Invalid token provided")
            return
        else:
            email = getUserEmail(self.request.headers['Authorization'])
            c = ndb.Key(urlsafe=id).get()
            if (email != c.owner_id):
                sendErrorResponse(self, 400, "You aren't authorized to alter the details of this car")
                return
            else:
                car_data = json.loads(self.request.body) #get the request parameters

                if ('year' in car_data.keys()):
                    yearVar = car_data['year']
                else:
                    yearVar = ""

                if ('make' in car_data.keys()):
                    makeVar = car_data['make']
                else:
                    makeVar = ""

                if ('model' in car_data.keys()):
                    modelVar = car_data['model']
                else:
                    modelVar = ""

                if ('in_space' in car_data.keys()):
                    inSpace = car_data['in_space']
                else:
                    inSpace = False

                if (inSpace == True):
                    if (c.in_space == False):
                        sendErrorResponse(self, 400, "Received in_space = true for a car that is currently not in a space")
                        return
                else: #in_space handling, requires coordination with Spaces
                    if (c.in_space == True): #if the car is in a space, empty the space
                        qry = Space.query()
                        qryResults = qry.fetch()
                        for x in qryResults:
                            if (x.current_car == c.id):
                                spaceId = x.id
                                break

                        s = ndb.Key("Space", long(spaceId)).get() #get the space object this car is located in
                        s.current_car = "" #empty the space
                        s.arrival_date = ""
                        s.put()

                if (yearVar == "" or makeVar == "" or modelVar == ""): #check for incomplete data
                    sendErrorResponse(self, 400, "Year, Make, and Model are all required")
                    return
                else:
                    c.year = yearVar #assign the new values to the car
                    c.make = makeVar 
                    c.model = modelVar
                    c.in_space = inSpace

                    c.put()

                    c_d = c.to_dict()
                    c_d['self'] = "/cars/" + id
                    sendSuccessResponse(self, 200, c_d)
                    return 

    # [END put handler]

    # [START delete handler]
    def delete(self, id):
        isAuthorized = checkAuth(self)

        if (isAuthorized == -1):
            sendErrorResponse(self, 400, "No authorization token provided")
            return
        elif (isAuthorized == 0):
            sendErrorResponse(self, 400, "Invalid token provided")
            return
        else:
            email = getUserEmail(self.request.headers['Authorization'])
            c = ndb.Key(urlsafe=id).get()

            if (email != c.owner_id):
                sendErrorResponse(self, 400, "You are not authorized to delete this car")
                return
            #if the car is in a space, empty the space
            if (c.in_space == True):
                #get the space the car is in
                qry = Space.query()
                qryResults = qry.fetch()
                for x in qryResults:
                    if (x.current_car == c.id):
                        spaceId = x.idbreak

                s = ndb.Key("Space", long(spaceId)).get()
                s.current_car = ""
                s.arrival_date = ""
                s.put()

            self.response.set_status(200)
            ndb.Key(urlsafe=id).delete()
            return
    # [END delete handler]

# [END CarHandler]

# [START SpaceHandler]
class SpaceHandler(webapp2.RequestHandler):
    # [START post handler]
    def post(self):
        space_data = json.loads(self.request.body) #get body of request

        if ('number' in space_data.keys()): #handle number entry
            numberVar = space_data['number']
        else:
            numberVar = None

        existingNumber = 0
        qry = Space.query() #query the space data to check if the number entered already exists
        qryResults = qry.fetch()
        for x in qryResults:
            x_d = x.to_dict()
            if (x_d['number'] == numberVar): #compare the number in the results to the number provided in the request
                existingNumber = 1
                break

        if (numberVar == None): #handle incomplete data being sent
            sendErrorResponse(self, 400, "Incomplete data sent")
            return
        else: #if complete data is sent
            if (existingNumber == 1): #if the provided number already exists, return an error
                sendErrorResponse(self, 400, "The space number provided already exists")
                return
            else: #otherwise, create the new spot and send success response
                new_space = Space(id="", number=numberVar, current_car="", arrival_date="") #assign the values
                new_space.put()
                new_space.id = str(new_space.key.id()) #get the id generated from the datastore
                new_space.put()
                space_dict = new_space.to_dict()
                space_dict['self'] = '/spaces/' + new_space.key.urlsafe() #add self element
                sendSuccessResponse(self, 200, space_dict)
                return
    # [END post handler]

    # [START get handler]
    def get(self, id=None):
        if id: #if an id is given, pull only the details for that space
            s = ndb.Key(urlsafe=id).get() #get the space referred to by the provided id
            s_d = s.to_dict()
            s_d['self'] = "/spaces/" + id
            if (s.current_car != ""): #handle the case where there is a car in the space
                c = ndb.Key("Car", long(s.current_car)).get()
                s_d['car_url'] = "/cars/" + c.key.urlsafe()
            else: #handle the case where the space is empty
                s_d['car_url'] = ""
            sendSuccessResponse(self, 200, s_d)
            return
        else: #if no id is provided, return details for all spaces
            results = []
            qry = Space.query()
            qryResults = qry.fetch()
            for x in qryResults:
                x_d = x.to_dict()
                x_d['self'] = "/spaces/" + x.key.urlsafe()
                if (x.current_car != ""): #handle the case where there is a car in the space
                    c = ndb.Key("Car", long(x.current_car)).get()
                    x_d['car_url'] = "/cars/" + c.key.urlsafe()
                else:
                    x_d['car_url'] = ""
                results.append(x_d) #add the space to the results
            sendSuccessResponse(self, 200, results)
            return
    # [END get handler]

    # [START patch handler]
    def patch(self, id):
        s = ndb.Key(urlsafe=id).get() #get the existing spot by id
        spot_data = json.loads(self.request.body) #get the request parameters

        continueVar = 0

        if ('number' in spot_data.keys()):
            s.number = spot_data['number']
            continueVar = 1

        if (continueVar == 1):
            s.put() #commit the changes to the spot

            s_d = s.to_dict()
            s_d['self'] = "/spots/" + id
            sendSuccessResponse(self, 200, s_d)
            return
        else:
            sendErrorResponse(self, 400, "No fields submitted to update")
            return
    # [END patch handler]

    # [START put handler]
    def put(self, id):
        s = ndb.Key(urlsafe=id).get()
        space_data = json.loads(self.request.body)
        continueVar = 1 #set to 0 if any validations fail. This is a cue to prevent changes from being made

        if ('number' in space_data.keys()):
            numberVar = space_data['number']
        else:
            continueVar = 0
            sendErrorResponse(self, 400, "Request didn't contain a spot number")
            return

        if ('current_car' in space_data.keys() and 'arrival_date' in space_data.keys()): #if a car is provided, an arrival date must also be provided
            carVar = space_data['current_car']
            dateVar = space_data['arrival_date']
            c = ndb.Key("Car", long(carVar)).get()
            if (s.current_car != ""):
                cc = ndb.Key("Car", long(s.current_car)).get()
        elif ('current_car' not in space_data.keys() and 'arrival_date' not in space_data.keys()):
            carVar = ""
            dateVar = ""
        else:
            continueVar = 0
            sendErrorResponse(self, 400, "current_car and arrival_date must both be provided or must both be empty")
            return

        if (continueVar == 1): #if validation was successful, continue to processing
            #if a car and arrival date were provided, ensure the user is authorized
            if (carVar != "" and dateVar != ""):
                isAuthorized = checkAuth(self)

                if (isAuthorized == -1):
                    sendErrorResponse(self, 400, "No authorization token provided")
                    return
                elif (isAuthorized == 0):
                    sendErrorResponse(self, 400, "Invalid token provided")
                    return
                else:
                    email = getUserEmail(self.request.headers['Authorization'])
                    if (email != c.owner_id):
                        sendErrorResponse(self, 400, "You are not authorized to alter the spot details of this vehicle")
                        return

                    if (s.current_car != ""):
                        if (email != cc.owner_id):
                            sendErrorResponse(self, 400, "You are not authorized to remove another owner's car from this space")
                            return

            #this section processes the spot number provided
            existingNumber = 0
            if (numberVar != s.number): #if a different number was provided, need to check that another spot doesn't already have that number
                qry = Space.query()
                qryResults = qry.fetch()
                for x in qryResults:
                    x_d = x.to_dict()
                    if (x_d['number'] == numberVar):
                        existingNumber = 1
                        break
            if (existingNumber == 1): #if the spot number exists, return an error
                sendErrorResponse(self, 400, "This spot number provided already exists")
                return
            else: #otherwise, overwrite the spot number
                s.number = numberVar
                s.put()

            if (s.current_car == ""): #if there isn't currently a car in the spot
                if (carVar != ""): #if requested field is not empty. if it is empty, it can be left alone
                    s.current_car = carVar
                    c.in_space = True #update the car's in_space field
                    c.put()
            else: #if there is currently a car in the spot
                cc.in_space = False #remove the current car from the space
                cc.put()

                if (carVar != ""):
                    s.current_car = carVar
                    c.in_space = True
                    c.put()
                else:
                    s.current_car = carVar

            s.put()

            s.arrival_date = dateVar
            s.put()

            #add the links to the response
            s_d = s.to_dict()
            s_d['self'] = "/spaces/" + id
            s_d['car_url'] = ""

            if (carVar != ""): #if a new car was passed in
                s_d['car_url'] = "/cars/" + c.key.urlsafe()

            sendSuccessResponse(self, 200, s_d)
            return

    # [END put handler]

    # [START delete handler]
    def delete(self, id):
        s = ndb.Key(urlsafe=id).get() #get the existing spot by id

        if (s.current_car != ""): #if there is a car in the spot, we need to make sure the user is authorized
            isAuthorized = checkAuth(self)
            if (isAuthorized == -1):
                sendErrorResponse(self, 400, "No authorization token provided")
                return
            elif (isAuthorized == 0):
                sendErrorResponse(self, 400, "Invalid authorization token")
                return
            else:
                email = getUserEmail(self.request.headers['Authorization'])
                cc = ndb.Key("Car", long(s.current_car)).get()
                if (email != cc.owner_id):
                    sendErrorResponse(self, 400, "You are not authorized to delete the spot containing another owner's car")
                    return

                cc.in_space = False
                cc.put()

        self.response.set_status(200)
        ndb.Key(urlsafe=id).delete()
        return

    # [END delete handler]
# [END SpaceHandler]

# [START CarLocationHandler]
class CarLocationHandler(webapp2.RequestHandler):

    # [START delete handler]
    def delete(self, id):
        isAuthorized = checkAuth(self)

        if (isAuthorized == -1):
            sendErrorResponse(self, 400, "No authorization token provided")
            return
        elif (isAuthorized == 0):
            sendErrorResponse(self, 400, "Invalid authorization token")
            return
        else:
            if id: #if an id is given, use this
                email = getUserEmail(self.request.headers['Authorization'])
                c = ndb.Key(urlsafe=id).get() #get the car referred to by that id
                if (c.owner_id != email):
                    sendErrorResponse(self, 400, "You are not authorized to make changes to this car's location")
                    return

                if (c.in_space == False): #if car is not in a space, return an error
                    sendErrorResponse(self, 400, "The car in the request is not in a space")
                else: #otherwise, empty the space and update
                    qry = Space.query()
                    qryResults = qry.fetch()
                    for x in qryResults:
                        if (x.current_car == c.id):
                            spaceId = x.id
                            break

                    s = ndb.Key("Space", long(spaceId)).get()
                    s.current_car = ""
                    s.arrival_date = ""
                    s.put()
                    c.in_space = False
                    c.put()

                    c_d = c.to_dict()
                    c_d['self'] = "/cars/" + id
                    sendSuccessResponse(self, 200, c_d)
                    return
            else:
                sendErrorResponse(self, 400, "Didn't receive an ID in the request")
                return

    # [END delete handler]

    # [START put handler]
    def put(self, id):
        if id:
            c = ndb.Key(urlsafe = id).get()
            request_data = json.loads(self.request.body)
            continueVar = 1

            isAuthorized = checkAuth(self)
            if (isAuthorized == -1):
                sendErrorResponse(self, 400, "No authorization token provided")
                return
            elif (isAuthorized == 0):
                sendErrorResponse(self, 400, "Invalid authorization token")
                return
            else:
                email = getUserEmail(self.request.headers['Authorization'])
                if (c.owner_id != email):
                    sendErrorResponse(self, 400, "You are not authorized to make changes to this car's location")
                    return

                if (c.in_space == True): #if the car is already in a spot return an error
                    continueVar = 0
                    sendErrorResponse(self, 400, "The car in the request is already in a space")
                else: #if the space number and arrival date are not included return an error
                    if ('space_number' not in request_data.keys() and 'arrival_date' not in request_data.keys()):
                        continueVar = 0
                        sendErrorResponse(self, 400, "space_number and arrival_date are both required")
                        return

                if (continueVar == 1):
                    carId = c.id
                    spaceNumber = request_data['space_number']
                    arrival_date = request_data['arrival_date']
                    spaceId = -1

                    qry = Space.query()
                    qryResults = qry.fetch()
                    for x in qryResults:
                        if (x.number == spaceNumber):
                            spaceId = x.id
                            break

                    if (spaceId == -1):
                        sendErrorResponse(self, 400, "No space exists with the supplied space number")
                        return

                    s = ndb.Key("Space", long(spaceId)).get()

                    if (s.current_car != ""): #if there is a car currently in the space
                        sendErrorResponse(self, 403, "The space requested is already occupied")
                        return

                    s.current_car = str(carId)
                    s.arrival_date = arrival_date
                    s.put()
                    c.in_space = True
                    c.put()

                    c_d = c.to_dict()
                    c_d['self'] = "/cars/" + id
                    sendSuccessResponse(self, 200, c_d)
        else:
            sendErrorResponse(self, 400, "Didn't receive an ID in the request")
            return


    # [END put handler]


# [END CarLocationHandler]

# [START main_page]
class MainPage(webapp2.RequestHandler):

    def get(self):
        state = hashlib.sha256(os.urandom(1024)).hexdigest() #generate a random key
        template_values = {
            'state' : state
        }

        # save the key to the datastore for later comparison
        new_key = State(id="", state=state)
        new_key.put()
        new_key.id = str(new_key.key.id())
        new_key.put()

        template = JINJA_ENVIRONMENT.get_template('index.html')
        self.response.write(template.render(template_values))
# [END main_page]

# [START OAuthHandler]
class OAuthHandler(webapp2.RequestHandler):

    def get(self):
        state = self.request.get('state') # get the state sent back
        code = self.request.get('code') # get the code sent by server
        good_req = 0

        qry = State.query()
        qryResults = qry.fetch()
        for x in qryResults: #for each key in the data store, compare the state we got back
            if (x.state == state):
                good_req = 1
                stateId = x.id
                ndb.Key("State", long(x.key.id())).delete()

        if (good_req == 1):
            client_id = "194873489442-er487ugbo93cmpnd9n2c73nlt1f20sie.apps.googleusercontent.com"
            client_secret = "AItyKEaCaZH0P5qEUujSKHUj"
            redirect_uri = "https://cloud-final-186221.appspot.com/oauth"

            payload = { #set up the post request to get the token
                'code' : code,
                'client_id' : client_id,
                'client_secret' : client_secret,
                'redirect_uri' : redirect_uri,
                'grant_type' : 'authorization_code'
            }

            #execute post request
            payload = urllib.urlencode(payload)
            result = urlfetch.fetch(url="https://www.googleapis.com/oauth2/v4/token", payload = payload, method=urlfetch.POST)

            time.sleep(0.3) # wait a little bit for the request to finish
            results = json.loads(result.content)
            token = results['access_token']
            
            template_values = {
                'state' : state,
                'token' : token
            }

            template = JINJA_ENVIRONMENT.get_template('oauth_landing.html')
            self.response.write(template.render(template_values))

        else:
            self.response.write("bad request")
# [END OAuthHandler]

allowed_methods = webapp2.WSGIApplication.allowed_methods
new_allowed_methods = allowed_methods.union(('PATCH',))
webapp2.WSGIApplication.allowed_methods = new_allowed_methods

# [START app]
app = webapp2.WSGIApplication([
    ('/', MainPage),
    ('/oauth', OAuthHandler),
    ('/cars', CarHandler),
    ('/cars/([\w|-]*)', CarHandler),
    ('/spaces', SpaceHandler),
    ('/spaces/([\w|-]*)', SpaceHandler),
    ('/cars/([\w|-]*)/in_space', CarLocationHandler)
], debug=True)
# [END app]