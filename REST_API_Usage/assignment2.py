#!/usr/bin/env python

# [START imports]
from google.appengine.ext import ndb
import webapp2
import json
# [END imports]

# [START Boat declaration]
class Boat(ndb.Model): #set up the structure of boat data
    id = ndb.StringProperty()
    name = ndb.StringProperty()
    type = ndb.StringProperty()
    length = ndb.IntegerProperty()
    at_sea = ndb.BooleanProperty()
# [END Boat declaration]

# [START Slip declaration]
class Slip(ndb.Model): #set up structure of slip data
    id = ndb.StringProperty()
    number = ndb.IntegerProperty()
    current_boat = ndb.StringProperty()
    arrival_date = ndb.StringProperty()
# [END Slip declaration]

# [START BoatHandler]
class BoatHandler(webapp2.RequestHandler):
    # [START post handler]
    def post(self): #post request handler
        boat_data = json.loads(self.request.body) #grab the body of the request

        if ('name' in boat_data.keys()): #handle name update
            nameVar = boat_data['name']
        else:
            nameVar = ""

        if ('type' in boat_data.keys()): #handle type update
            typeVar = boat_data['type']
        else:
            typeVar = ""

        if ('length' in boat_data.keys()): #handle length update
            lengthVar = boat_data['length']
        else:
            lengthVar = None

        if (nameVar == "" or typeVar == "" or lengthVar == None): #set up a response if incomplete data is sent
            self.response.headers.add('Content-Type', 'Application/JSON')
            self.response.headers.add('Status', '400 Bad Request')
            r = {}
            r['message'] = "Incomplete data sent"
            self.response.write(json.dumps(r))
        else: #if complete data is supplied, 
            new_boat = Boat(id="", name=nameVar, type=typeVar, length=lengthVar, at_sea=True) #assign values 
            new_boat.put() #save the fields we have
            new_boat.id = str(new_boat.key.id()) #get the id generated by datastore
            new_boat.put() #save the id to the boat we created
            boat_dict = new_boat.to_dict() #convert to a dictionary
            boat_dict['self'] = '/boats/' + new_boat.key.urlsafe() #add self element to dictionary
            self.response.headers.add('Status', '200 OK')
            self.response.headers.add('Content-Type', 'Application/JSON')
            self.response.write(json.dumps(boat_dict)) #send back the results
    # [END post handler]

    # [START get handler]
    def get(self, id=None): #get request handler
        if id: #if an id is given, use this
            b = ndb.Key(urlsafe=id).get() #get the boat object referred to by that id
            b_d = b.to_dict() #convert to a dictionary
            b_d['self'] = "/boats/" + id #create the self link
            self.response.headers.add('Status', '200 OK')
            self.response.headers.add('Content-Type', 'Application/JSON')            
            self.response.write(json.dumps(b_d)) #send back the results
        else: #if no id is given, use this
            results = [] #create array to store query results
            qry = Boat.query()
            qryResults = qry.fetch()
            for x in qryResults: #for each result, serialize the output so it can be sent to JSON
                x_d = x.to_dict()
                x_d['self'] = "/boats/" + x.key.urlsafe()
                results.append(x_d) #add the dictionary to results
            self.response.headers.add('Status', '200 OK')
            self.response.headers.add('Content-Type', 'Application/JSON')
            self.response.write(json.dumps(results)) #respond with array of JSON objects
    # [END get handler]

    # [START patch handler]
    def patch(self, id): #update request handler
        b = ndb.Key(urlsafe=id).get() #get the existing boat by id
        boat_data = json.loads(self.request.body) #get the request parameters

        continueVar = 0

        #Check if any fields were sent to be updated
        if ('name' in boat_data.keys()): #if name is one of the fields requested to change, do this
            b.name = boat_data['name']
            continueVar = 1

        if ('type' in boat_data.keys()): #if type is one of the fields requested to change, do this
            b.type = boat_data['type']
            continueVar = 1

        if ('length' in boat_data.keys()): #if length is one of the fields requeested to change, do this
            b.length = boat_data['length']
            continueVar = 1

        if (continueVar == 1): #if a field was sent to be changed, continue
            b.put() #commmit the changes to the boat

            b_d = b.to_dict() #add the self link for the response
            b_d['self'] = "/boats/" + id

            self.response.headers.add('Status', '200 OK')
            self.response.headers.add('Content-Type', 'Application/JSON')
            self.response.write(json.dumps(b_d)) #send the response
        else: #if no update field was sent, send an error message
            self.response.headers.add('Content-Type', 'Application/JSON')
            self.response.headers.add('Status', '400 Bad Request')
            r = {}
            r['message'] = "No fields submitted to update"
            self.response.write(json.dumps(r))            
    # [END patch handler]

    # [START put handler]
    def put(self, id): #replace request handler
        b = ndb.Key(urlsafe=id).get() #get the existing boat by id
        boat_data = json.loads(self.request.body) #get the request parameters

        if ('name' in boat_data.keys()): #handle name update
            nameVar = boat_data['name']
        else:
            nameVar = ""

        if ('type' in boat_data.keys()): #handle type update
            typeVar = boat_data['type']
        else:
            typeVar = ""

        if ('length' in boat_data.keys()): #handle length update
            lengthVar = boat_data['length']
        else:
            lengthVar = None

        if ('at_sea' in boat_data.keys()): #handle at_sea update
            at_sea = boat_data['at_sea']
        else:
            at_sea = True

        b.name = nameVar #assign new values to the boat
        b.type = typeVar
        b.length = lengthVar
        b.at_sea = at_sea

        b.put() #commit the changes to the boat

        b_d = b.to_dict() #write the self link
        b_d['self'] = "/boats/" + id

        self.response.write(json.dumps(b_d)) #send the response
    # [END put handler]

    # [START delete handler]
    def delete(self, id):
        ndb.Key(urlsafe=id).delete()

        self.response.headers.add('Status', '200 OK')
# [END BoatHandler]

# [START SlipHandler]
class SlipHandler(webapp2.RequestHandler):
    # [START post handler]
    def post(self): #post request handler
        slip_data = json.loads(self.request.body) #grab the body of the request

        if ('number' in slip_data.keys()): #handle name update
            numberVar = slip_data['number']
        else:
            numberVar = None

        if ('arrival_date' in slip_data.keys()): #handle length update
            arrival_date = slip_data['arrival_date']
        else:
            arrival_date = ""

        existingNumber = 0
        qry = Slip.query() #query the slips data to check if the slip number entered already exists
        qryResults = qry.fetch()
        for x in qryResults: #iterate through each query result
            x_d = x.to_dict()
            if (x_d['number'] == numberVar): #compare the number in the results to the number provided request
                existingNumber = 1
                break

        if (numberVar == None or arrival_date == ""): #set up a response if incomplete data is sent
            self.response.headers.add('Content-Type', 'Application/JSON')
            self.response.headers.add('Status', '400 Bad Request')
            r = {}
            r['message'] = "Incomplete data sent"
            self.response.write(json.dumps(r))
        else: #if complete data is supplied
            if (existingNumber == 1): #if slip number already exists, return an error
                self.response.headers.add('Content-Type', 'Application/JSON')
                self.response.headers.add('Status', '400 Bad Request')
                r = {}
                r['message'] = "The slip number provided already exists"
                self.response.write(json.dumps(r))
            else: #otherwise, create the new slip and send a success response
                new_slip = Slip(id="", number=numberVar, current_boat="", arrival_date=arrival_date) #assign values 
                new_slip.put() #save the fields we have
                new_slip.id = str(new_slip.key.id()) #get the id generated by datastore
                new_slip.put() #save the id to the boat we created
                slip_dict = new_slip.to_dict() #convert to a dictionary
                slip_dict['self'] = '/slips/' + new_slip.key.urlsafe() #add self element to dictionary
                self.response.headers.add('Status', '200 OK')
                self.response.headers.add('Content-Type', 'Application/JSON')
                self.response.write(json.dumps(slip_dict)) #send back the results
    # [END post handler]

    # [START get handler]
    def get(self, id=None): #get request handler
        if id: #if an id is given, use this
            s = ndb.Key(urlsafe=id).get() #get the boat object referred to by that id
            s_d = s.to_dict() #convert to a dictionary
            s_d['self'] = "/slips/" + id #create the self link
            self.response.headers.add('Status', '200 OK')
            self.response.headers.add('Content-Type', 'Application/JSON')            
            self.response.write(json.dumps(s_d)) #send back the results
        else: #if no id is given, use this
            results = [] #create array to store query results
            qry = Slip.query()
            qryResults = qry.fetch()
            for x in qryResults: #for each result, serialize the output so it can be sent to JSON
                x_d = x.to_dict()
                x_d['self'] = "/slips/" + x.key.urlsafe()
                results.append(x_d) #add the dictionary to results
            self.response.headers.add('Status', '200 OK')
            self.response.headers.add('Content-Type', 'Application/JSON')
            self.response.write(json.dumps(results)) #respond with array of JSON objects
    # [END get handler]

# [END SlipHandler]

# [START main_page]
class MainPage(webapp2.RequestHandler):

    def get(self):
        self.response.write("hello")
# [END main_page]

allowed_methods = webapp2.WSGIApplication.allowed_methods
new_allowed_methods = allowed_methods.union(('PATCH',))
webapp2.WSGIApplication.allowed_methods = new_allowed_methods

# [START app]
app = webapp2.WSGIApplication([
    ('/', MainPage),
    ('/boats', BoatHandler),
    ('/boats/(.*)', BoatHandler),
    ('/slips', SlipHandler),
    ('/slips/(.*)', SlipHandler)
], debug=True)
# [END app]